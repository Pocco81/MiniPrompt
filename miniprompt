#!/bin/bash
# shellcheck disable=2154

# --> metadata
config_file="/tmp/miniprompt/cnf.toml"

# colors
declare -A colors=(
    ["spc"]=' '
    ["nc"]='\[\033[0m\]'
    ["gray"]='\[\033[0;30m\]'
    ["gray_br"]='\[\033[1;30m\]'
    ["red"]='\[\033[0;31m\]'
    ["red_br"]='\[\033[1;31m\]'
    ["green"]='\[\033[0;32m\]'
    ["green_br"]='\[\033[1;32m\]'
    ["yellow"]='\[\033[0;33m\]'
    ["yellow_br"]='\[\033[1;33m\]'
    ["purple"]='\[\033[0;35m\]'
    ["purple_br"]='\[\033[1;35m\]'
    ["white"]='\[\033[0;37m\]'
    ["white_br"]='\[\033[1;37m\]'
    ["blue"]='\[\033[0;34m\]'
    ["blue_br"]='\[\033[1;34m\]'
    ["cyan"]='\[\033[0;36m\]'
    ["cyan_br"]='\[\033[1;36m\]'
)

# help
script_help=$(
    cat <<EOF

MiniPrompt is a minimal and versatile prompt suitable for any type of machine. You can also use this script to toggle extensions on and off 'on the fly'!

Flags:
    -h,--help                                   See this help message.
EOF
)

# usage
# we have to source the script as an alias if we want to export environment variables: https://stackoverflow.com/questions/16618071/can-i-export-a-variable-to-the-environment-from-a-bash-script-without-sourcing-i
# source /tmp/miniprompt/main
# alias mnp="source /tmp/miniprompt/main"

function parse_config() {
    [[ -f $1 ]] || {
        echo "$1 is not a file." >&2
        return 1
    }
    entry_regex="^[[:blank:]]*([[:alpha:]_][[:alnum:]_-]*)[[:blank:]]*=[[:blank:]]*('[^']+'|\"[^\"]+\"|[^#[:blank:]]+)[[:blank:]]*(#.*)*$"
    while read -r line; do
        [[ -n $line ]] || continue
        [[ $line =~ $entry_regex ]] || continue
        key=${BASH_REMATCH[1]}
        value=${BASH_REMATCH[2]#[\'\"]} # strip quotes
        value=${value%[\'\"]}
        declare -g "${key}"="${value}"
    done <"$1"
}

function export_ps1_vars() {
    export PS1_previous_exit
    export PS1_prefix
    export PS1_content
    export PS1_suffix
}

function enhance_autocompletion() {
    if [[ "$enhanced_autocompletion" == "true" ]]; then
        bind 'set colored-stats on'
        bind 'set colored-completion-prefix on'
        bind 'set completion-ignore-case on'
        bind 'set completion-map-case on'
        bind 'set expand-tilde on'
        bind 'set mark-directories on'
        bind 'set mark-symlinked-directories on'
        bind 'set show-all-if-ambiguous on'
        bind 'set show-all-if-unmodified on'
        bind 'set skip-completed-text on'
        shopt -s 'cdspell'
        shopt -s 'checkwinsize'
        shopt -s 'dirspell'
    fi
}

function enhance_history_format() {
    if [[ "$enhanced_history_format" == "true" ]]; then
        export HISTCONTROL='ignoreboth:erasedups'
        export HISTTIMEFORMAT='[%Y-%m-%d %T] '
        shopt -s 'histappend'
    fi
}

function load_dircolors() {
    if [[ "$dircolors" == "true" ]]; then
        if [ -x "$(command -v dircolors)" ]; then
            if [ -r "$HOME/.dircolors" ]; then
                eval "$(dircolors -b "$HOME/.dircolors")"
            else
                eval "$(dircolors -b)"
            fi
        fi
    fi
}

function reset_prompt() {
    PS1_previous_exit="$?"
    PS1_prefix="${prefix}" # window title
    for color in "${!colors[@]}"; do
        ps_content=${ps_content/"</${color}>"/"${colors[$color]}"}
    done
    PS1_content="${ps_content}"
    PS1_suffix="${colors[$succeeded]}${normal_mark}\[\033[0m\] "
}

function clean_variables() {
    unset PS1_prefix \
        PS1_content \
        PS1_suffix \
        PS1_previous_exit
}

function assert_extension() {
    name=$1
    enabled=$2

    if [[ "$enabled" == "true" ]]; then
        bin_cmd="$(command -v ${name})"
        if [[ ! -z "$bin_cmd" ]]; then
            case "$name" in
            "git")
                if [[ "$($bin_cmd rev-parse --is-inside-work-tree 2>/dev/null)" = 'true' ]]; then
                    PS1_content="${PS1_content:-}${colors[$git_color]}(${git_branch} $($bin_cmd branch --show-current))\[\033[0m\] "
                fi
                ;;
            "ssh")
                if [[ -n "$SSH_CONNECTION" ]]; then
                    PS1_prefix="\[\e]0;\u@\h \w\a\]"
                    PS1_content="\[\e[2m\]\u@\h\[\e[0m\] ${PS1_content}"
                fi
                ;;
            "kube")
                local context
                local namespace
                context="$(${bin_cmd} config view -o=jsonpath='{.current-context}')"
                namespace="$(${bin_cmd} config view -o=jsonpath="{.contexts[?(@.name==\"${context}\")].context.namespace}")"
                PS1_content="${PS1_content:-} ${kube}\[\e[34m\]${context}${namespace:+:$namespace}\[\e[0m\]"
                ;;
            esac
        fi
    fi
}


function turn_ext() {
    task=$1
    var=$2
    if [[ "${task}" == "e" ]] || [[ "${task}" == "enable" ]]; then
        echo "true"
    elif [[ "${task}" == "d" ]] || [[ "${task}" == "disable" ]]; then
        echo "false"
    elif [[ "${task}" == "t" ]] || [[ "${task}" == "toggle" ]]; then
        if [[ "${var}" == "false" ]]; then echo "true"; fi
        echo "false"
    fi
}

function on_da_fly() {
    extension=$1
    task=$2

    case "$extension" in
    "gt" | "git")
        var="ext_git"
        export ${var}="$(turn_ext "${task}" "${var}")"
        ;;
    "sh" | "ssh")
        var="ext_ssh"
        export ${var}="$(turn_ext "${task}" "${var}")"
        ;;
    "kp" | "kube" | "kubernetes")
        var="ext_kubernetes"
        export ${var}="$(turn_ext "${task}" "${var}")"
        ;;
    "-h" | "--help")
        echo "$script_help"
        # exit 0    # causes shell to close
        ;;
    *)
        echo "Error: command was not recognized"
        ;;
    esac
}

function pre_prompt() {
    export_ps1_vars
}

function make_prompt() {
    reset_prompt

    if [[ "$colored_exit_status" == "true" ]]; then
        [ "$PS1_previous_exit" -ne 0 ] && PS1_suffix="${colors[$failed]}${error} \[\e[m\]"
    fi

    PROMPT_DIRTRIM=${dirtrim}

    assert_extension "git" "${ext_git}"
    assert_extension "ssh" "${ext_ssh}"
    assert_extension "kubectl" "${ext_kubernetes}"

    export PS1="${PS1_prefix:-}${PS1_content:-}${PS1_suffix:-}"
    history -a
    clean_variables
}

function post_prompt() {
    enhance_autocompletion
    enhance_history_format
    load_dircolors
}

main() {
    if [[ ! "$#" > 0 ]]; then
        parse_config $config_file
        pre_prompt
        export PROMPT_COMMAND="make_prompt;$PROMPT_COMMAND"
        post_prompt
    else
        on_da_fly "${1}" "${2}"
    fi
}

main "$@"
