#!/bin/bash
# shellcheck disable=2154
# shellcheck disable=2034

# --> metadata
config="$([ -z "${XDG_CONFIG_HOME}" ] && echo "${HOME}/.config" || echo "${XDG_CONFIG_HOME}")/miniprompt/conf.toml"

# clrs
declare -A clrs=(
    ["spc"]=' '
    ["nc"]='\[\033[0m\]'
    ["gray"]='\[\033[0;30m\]'
    ["gray_br"]='\[\033[1;30m\]'
    ["red"]='\[\033[0;31m\]'
    ["red_br"]='\[\033[1;31m\]'
    ["green"]='\[\033[0;32m\]'
    ["green_br"]='\[\033[1;32m\]'
    ["yellow"]='\[\033[0;33m\]'
    ["yellow_br"]='\[\033[1;33m\]'
    ["magenta"]='\[\033[0;35m\]'
    ["magenta_br"]='\[\033[1;35m\]'
    ["white"]='\[\033[0;37m\]'
    ["white_br"]='\[\033[1;37m\]'
    ["blue"]='\[\033[0;34m\]'
    ["blue_br"]='\[\033[1;34m\]'
    ["cyan"]='\[\033[0;36m\]'
    ["cyan_br"]='\[\033[1;36m\]'
)

# help
script_help=$(
    cat <<EOF

MiniPrompt is a minimal and versatile prompt suitable for any type of machine.
You can also use it to toggle extensions on and off 'on the fly'!

Args:
	gt, git							handle the git extension
	sh, hostname					handle the hostname extension
	kb, kube, kubernetes			handle the kubernetes extensions

Modifiers for the args:
	t, toggle						Toggle extension on and off
	e, enable						Enable extension
	d, disable						Disable extension

Flags:
    -h,--help                                   See this help message.
EOF
)

function load_defualt_settings() {
    colored_exit_status="true"
    dirtrim=2
    enhanced_autocompletion="true"
    enhanced_history_format="true"
    dircolors="true"

    prefix="\[\e]0;\w\a\]"
    ps_content="</yellow>\w</nc></spc>"
    normal_symbol="➜"
    error_symbol="✗"
    succeeded="green"
    failed="red"

    ext_git="false"
    ext_hostname="false"
    ext_kubernetes="false"

}

function load_config() {
    load_defualt_settings
    [[ -f $1 ]] || {
        return 1
    }
    entry_regex="^[[:blank:]]*([[:alpha:]_][[:alnum:]_-]*)[[:blank:]]*=[[:blank:]]*('[^']+'|\"[^\"]+\"|[^#[:blank:]]+)[[:blank:]]*(#.*)*$"
    while read -r line; do
        [[ -n $line ]] || continue
        [[ $line =~ $entry_regex ]] || continue
        key=${BASH_REMATCH[1]}
        value=${BASH_REMATCH[2]#[\'\"]} # strip quotes
        value=${value%[\'\"]}
        declare -g "${key}"="${value}"
    done <"$1"
}

function export_ps1_vars() {
    export PS1_previous_exit
    export PS1_prefix
    export PS1_content
    export PS1_suffix
}

function enhance_autocompletion() {
    if [[ "$enhanced_autocompletion" == "true" ]]; then
        bind 'set colored-stats on'
        bind 'set colored-completion-prefix on'
        bind 'set completion-ignore-case on'
        bind 'set completion-map-case on'
        bind 'set expand-tilde on'
        bind 'set mark-directories on'
        bind 'set mark-symlinked-directories on'
        bind 'set show-all-if-ambiguous on'
        bind 'set show-all-if-unmodified on'
        bind 'set skip-completed-text on'
        shopt -s 'cdspell'
        shopt -s 'checkwinsize'
        shopt -s 'dirspell'
    fi
}

function enhance_history_format() {
    if [[ "$enhanced_history_format" == "true" ]]; then
        export HISTCONTROL='ignoreboth:erasedups'
        export HISTTIMEFORMAT='[%Y-%m-%d %T] '
        shopt -s 'histappend'
    fi
}

function load_dircolors() {
    if [[ "$dircolors" == "true" ]]; then
        if [ -x "$(command -v dircolors)" ]; then
            if [ -r "$HOME/.dircolors" ]; then
                eval "$(dircolors -b "$HOME/.dircolors")"
            else
                eval "$(dircolors -b)"
            fi
        fi
    fi
}

function reset_prompt() {
    PS1_previous_exit="$?"
    PS1_prefix="${prefix}" # window title
    for clr in "${!clrs[@]}"; do ps_content=${ps_content/"</${clr}>"/"${clrs[$clr]}"}; ps_suffix=${ps_suffix/"</${clr}>"/"${clrs[$clr]}"}; done
    PS1_content="${ps_content}"
    PS1_suffix="${ps_suffix}${clrs[$normal_color]}"
}

function clean_variables() {
    unset PS1_prefix \
        PS1_content \
        PS1_suffix \
        PS1_previous_exit
}

function assert_extension() {
    name=$1
    enabled=$2

    if [[ "$enabled" == "true" ]]; then
		unit="[empty_${name}]"
		case "$name" in
		"git")
			bin_cmd="$(command -v ${name})"
			if [[ "$($bin_cmd rev-parse --is-inside-work-tree 2>/dev/null)" = 'true' ]]; then
				unit=$($bin_cmd branch --show-current)
			fi
			;;
		"hostname")
				unit="\h"
			;;
		"kube")
			bin_cmd="$(command -v ${name})"
			local context
			local namespace
			context="$(${bin_cmd} config view -o=jsonpath='{.current-context}')"
			namespace="$(${bin_cmd} config view -o=jsonpath="{.contexts[?(@.name==\"${context}\")].context.namespace}")"
			PS1_content="${PS1_content:-} ${kube_symbol}\[\e[34m\]${context}${namespace:+:$namespace}\[\e[0m\]"
			;;
		esac

		val="${name}_struct"
		parsed_struct="${!val}"
		for clr in "${!clrs[@]}"; do parsed_struct=${parsed_struct/"</${clr}>"/"${clrs[$clr]}"}; done
		PS1_content="${PS1_content:-}${parsed_struct/"</unit>"/"${unit}"}${clrs[$normal_color]}"
    fi
}

function turn_ext() {
    task=$1
    var=$2
    if [[ "${task}" == "e" ]] || [[ "${task}" == "enable" ]]; then
        echo "true"
    elif [[ "${task}" == "d" ]] || [[ "${task}" == "disable" ]]; then
        echo "false"
    elif [[ "${task}" == "t" ]] || [[ "${task}" == "toggle" ]]; then
        if [[ "${var}" == "false" ]]; then echo "true"; fi
        echo "false"
    fi
}

function on_da_fly() {
    extension=$1
    task=$2

    case "$extension" in
    "gt" | "git")
        var="ext_git"
        export ${var}="$(turn_ext "${task}" "${var}")"
        ;;
    "hs" | "hostname")
        var="ext_hostname"
        export ${var}="$(turn_ext "${task}" "${var}")"
        ;;
    "kp" | "kube" | "kubernetes")
        var="ext_kubernetes"
        export ${var}="$(turn_ext "${task}" "${var}")"
        ;;
    "-h" | "--help")
        echo "$script_help"
        # exit 0    # causes shell to close
        ;;
    *)
        echo "Error: command was not recognized"
        ;;
    esac
}

function pre_prompt() {
    export_ps1_vars
}

function make_prompt() {
    reset_prompt

    if [[ "$colored_exit_status" == "true" ]]; then
        [ "$PS1_previous_exit" -ne 0 ] && PS1_suffix="${clrs[$failed]}${error_symbol} ${clrs[$normal_color]}"
    fi

    PROMPT_DIRTRIM=${dirtrim}

    assert_extension "git" "${ext_git}"
    assert_extension "hostname" "${ext_hostname}"
    assert_extension "kubectl" "${ext_kubernetes}"

    export PS1="${PS1_prefix:-}${PS1_content:-}${PS1_suffix:-}"
    history -a
    clean_variables
}

function post_prompt() {
    enhance_autocompletion
    enhance_history_format
    load_dircolors
}

main() {
    if [[ ! "$#" > 0 ]]; then
        load_config "${config}"
        pre_prompt
        export PROMPT_COMMAND="make_prompt;$PROMPT_COMMAND"
        post_prompt
    else
        on_da_fly "${1}" "${2}"
    fi
}

main "$@"
